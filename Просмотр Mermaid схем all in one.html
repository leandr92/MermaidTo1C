<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mermaid Схемы (Транспилировано для 1С)</title>
    <style>
/* Базовые стили для Mermaid диаграмм */
.mermaid {
  font-family: "trebuchet ms", verdana, arial, sans-serif;
  font-size: 16px;
  fill: #333;
}

.mermaid .label {
  font-family: "trebuchet ms", verdana, arial, sans-serif;
  color: #333;
}

.mermaid .node rect,
.mermaid .node circle,
.mermaid .node ellipse,
.mermaid .node polygon {
  fill: #ECECFF;
  stroke: #9370DB;
  stroke-width: 1px;
}

.mermaid .node .label {
  text-align: center;
}

.mermaid .edgePath .path {
  stroke: #333333;
  stroke-width: 1.5px;
}

.mermaid .edgeLabel {
  background-color: #e8e8e8;
  text-align: center;
}

.mermaid .cluster rect {
  fill: #ffffde;
  stroke: #aaaa33;
  stroke-width: 1px;
}

.mermaid .cluster text {
  fill: #333;
}

.mermaid .actor {
  stroke: #CCCCFF;
  fill: #ECECFF;
}

.mermaid text.actor {
  fill: #000;
  stroke: none;
}

.mermaid .actor-line {
  stroke: grey;
}

.mermaid .messageLine0 {
  stroke-width: 1.5;
  stroke-dasharray: "2 2";
  marker-end: "url(#arrowhead)";
  stroke: #333;
}

.mermaid .messageLine1 {
  stroke-width: 1.5;
  stroke-dasharray: "2 2";
  stroke: #333;
}

.mermaid #arrowhead {
  fill: #333;
}

.mermaid .sequenceNumber {
  fill: #fff;
}

.mermaid .note {
  fill: #fff5ad;
  stroke: #aaa;
}

.mermaid .note .label {
  fill: #000;
}

.mermaid .activation0 {
  fill: #f4f4f4;
  stroke: #666;
}

.mermaid .activation1 {
  fill: #f4f4f4;
  stroke: #666;
}

.mermaid .activation2 {
  fill: #f4f4f4;
  stroke: #666;
}
    </style>
</head>
<body>
    <h1>Mermaid Схемы</h1>
    
    <div id="mermaid-container">
        <!-- Основная диаграмма с кириллицей - используем flowchart-elk для угловатых линий -->
        <pre class="mermaid">flowchart-elk TD
A[Клиент] --> B[Балансировщик нагрузки]
B --> C[Сервер1]
B --> D[Сервер2]
C --> E[База данных]
D --> E</pre>

        <!-- Альтернативный вариант с обычным graph для сравнения -->
        <pre class="mermaid" data-diagram-type="graph">graph TD
A[Клиент] --> B[Балансировщик нагрузки]
B --> C[Сервер1]
B --> D[Сервер2]
C --> E[База данных]
D --> E</pre>

        <pre class="mermaid">sequenceDiagram
participant Alice
participant Bob
Alice->>Bob: Hello Bob, how are you?
Bob-->>Alice: I am good thanks!</pre>
    </div>

    <!-- Критически важные полифиллы - должны быть ДО загрузки mermaid -->
    <script>
        // Полифилл для Object.hasOwn (ES2022) - устанавливается ДО загрузки mermaid
        if (typeof Object.hasOwn === 'undefined') {
            Object.hasOwn = function(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            };
        }
        
        // Полифилл для Array.prototype.at() (ES2022) - критически важен для Mermaid 11.x
        if (!Array.prototype.at) {
            Array.prototype.at = function(index) {
                var len = this.length;
                var relativeIndex = index >= 0 ? index : len + index;
                if (relativeIndex < 0 || relativeIndex >= len) {
                    return undefined;
                }
                return this[relativeIndex];
            };
        }
        
        // Полифилл для SVGElement.getBBox() - критически важен для Mermaid в старых браузерах
        // Работает для всех SVG элементов, включая те, что возвращаются через D3 .node()
        (function() {
            function getBBoxPolyfill() {
                var element = this;
                
                // Если это D3 элемент с методом node(), получаем нативный элемент
                if (element && typeof element.node === 'function') {
                    element = element.node();
                }
                
                // Если элемент null или undefined, возвращаем значения по умолчанию
                if (!element) {
                    return { x: 0, y: 0, width: 100, height: 100 };
                }
                
                // Пробуем использовать нативный getBBox, если доступен
                if (element.getBBox && typeof element.getBBox === 'function') {
                    try {
                        return element.getBBox();
                    } catch (e) {
                        // Если getBBox выбросил ошибку, вычисляем вручную
                    }
                }
                
                // Вычисляем bounding box вручную
                var bbox = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
                
                try {
                    // Пробуем получить через getBoundingClientRect
                    if (element.getBoundingClientRect) {
                        var rect = element.getBoundingClientRect();
                        bbox.width = rect.width || 0;
                        bbox.height = rect.height || 0;
                    }
                    
                    // Пробуем получить атрибуты width и height
                    if (element.getAttribute) {
                        var width = element.getAttribute('width');
                        var height = element.getAttribute('height');
                        if (width) {
                            bbox.width = parseFloat(width) || bbox.width;
                        }
                        if (height) {
                            bbox.height = parseFloat(height) || bbox.height;
                        }
                    }
                    
                    // Пробуем получить через style
                    if (element.style) {
                        var styleWidth = element.style.width;
                        var styleHeight = element.style.height;
                        if (styleWidth) {
                            bbox.width = parseFloat(styleWidth) || bbox.width;
                        }
                        if (styleHeight) {
                            bbox.height = parseFloat(styleHeight) || bbox.height;
                        }
                    }
                    
                    // Если ничего не получилось, возвращаем минимальные значения
                    if (bbox.width === 0 && bbox.height === 0) {
                        bbox.width = 100;
                        bbox.height = 100;
                    }
                } catch (e) {
                    // В случае ошибки возвращаем значения по умолчанию
                    bbox.width = 100;
                    bbox.height = 100;
                }
                
                return bbox;
            }
            
            // Добавляем полифилл для всех SVG элементов
            var svgElementTypes = ['SVGElement', 'SVGTextElement', 'SVGRectElement', 'SVGPathElement', 
                                  'SVGCircleElement', 'SVGEllipseElement', 'SVGLineElement', 'SVGPolygonElement',
                                  'SVGPolylineElement', 'SVGGElement', 'SVGUseElement'];
            
            svgElementTypes.forEach(function(typeName) {
                if (typeof window[typeName] !== 'undefined' && window[typeName].prototype) {
                    if (!window[typeName].prototype.getBBox || typeof window[typeName].prototype.getBBox !== 'function') {
                        window[typeName].prototype.getBBox = getBBoxPolyfill;
                    }
                }
            });
            
            // Также добавляем для всех элементов, которые могут быть SVG (на всякий случай)
            if (typeof Element !== 'undefined' && Element.prototype) {
                // Перехватываем getBBox на любых элементах, которые могут быть SVG
                var originalGetBBox = Element.prototype.getBBox;
                if (!originalGetBBox || typeof originalGetBBox !== 'function') {
                    Element.prototype.getBBox = function() {
                        // Проверяем, является ли элемент SVG элементом
                        if (this.namespaceURI === 'http://www.w3.org/2000/svg' || this.tagName && this.tagName.toLowerCase().indexOf('svg') !== -1) {
                            return getBBoxPolyfill.call(this);
                        }
                        // Если не SVG, возвращаем значения по умолчанию
                        return { x: 0, y: 0, width: 100, height: 100 };
                    };
                }
            }
        })();
    </script>
    
    <!-- Транспилированный бандл Mermaid для 1С (включает все необходимые полифиллы) -->
    <!-- Версия 11.12.2 - переименован для обхода кэша браузера -->
    <script src="dist/mermaid_all_in_one_v11.12.2.js"></script>
    
    <script>
        // Инициализация Mermaid после загрузки скрипта
        // Mermaid уже инициализирован с startOnLoad: true, но вызываем run() для надежности
        (function() {
            'use strict';
            
            // Функция для детального анализа SVG элементов после отрисовки
            function analyzeSVGElements() {
                console.log('=== HTML DEBUG: Анализ SVG элементов ===');
                var svgElements = document.querySelectorAll('.mermaid svg');
                console.log('HTML DEBUG: Найдено SVG элементов:', svgElements.length);
                
                svgElements.forEach(function(svg, index) {
                    console.log('HTML DEBUG: --- SVG #' + index + ' ---');
                    
                    // Получаем родительский элемент с классом mermaid
                    var mermaidElement = svg.closest('.mermaid');
                    var diagramText = mermaidElement ? mermaidElement.textContent.trim() : 'N/A';
                    var diagramType = diagramText.split('\n')[0] || diagramText.substring(0, 50);
                    console.log('HTML DEBUG: Тип диаграммы:', diagramType);
                    
                    // Проверяем размеры
                    console.log('HTML DEBUG: Размеры SVG:', {
                        width: svg.getAttribute('width'),
                        height: svg.getAttribute('height'),
                        viewBox: svg.getAttribute('viewBox')
                    });
                    
                    // Проверяем классы
                    var svgClasses = svg.getAttribute('class') || '';
                    console.log('HTML DEBUG: Классы SVG:', svgClasses);
                    
                    // Анализируем пути (paths) - ключевой момент для определения типа линий
                    var paths = svg.querySelectorAll('path');
                    console.log('HTML DEBUG: Количество path элементов:', paths.length);
                    
                    var curvedPaths = 0;
                    var straightPaths = 0;
                    var mixedPaths = 0;
                    
                    paths.forEach(function(path, pathIndex) {
                        var d = path.getAttribute('d') || '';
                        if (!d) return;
                        
                        // Команды для кривых: C (cubic bezier), S (smooth cubic), Q (quadratic), T (smooth quadratic)
                        var hasCurves = /[CcSsQqTt]/.test(d);
                        // Команды для прямых: L (line), H (horizontal), V (vertical), Z (close path)
                        var hasLines = /[LlHhVvZz]/.test(d);
                        // Команда M (move) не считается ни кривой, ни линией
                        var isOnlyMove = /^[Mm\s\d.,-]+$/.test(d.replace(/[LlHhVvZzCcSsQqTt]/g, ''));
                        
                        if (hasCurves && !hasLines && !isOnlyMove) {
                            curvedPaths++;
                        } else if (hasLines && !hasCurves) {
                            straightPaths++;
                        } else if (hasCurves && hasLines) {
                            mixedPaths++;
                        }
                        
                        // Логируем первые несколько путей детально
                        if (pathIndex < 3) {
                            console.log('HTML DEBUG: Path #' + pathIndex + ':');
                            console.log('  - d атрибут (первые 150 символов):', d.substring(0, 150));
                            console.log('  - Содержит кривые?', hasCurves);
                            console.log('  - Содержит прямые линии?', hasLines);
                            console.log('  - Тип линии:', hasCurves && !hasLines ? 'СКРУГЛЕННАЯ (кривая)' : 
                                                     hasLines && !hasCurves ? 'УГЛОВАТАЯ (прямая)' : 
                                                     'СМЕШАННАЯ');
                        }
                    });
                    
                    console.log('HTML DEBUG: Статистика путей:');
                    console.log('  - Скругленные (только кривые):', curvedPaths);
                    console.log('  - Угловатые (только прямые):', straightPaths);
                    console.log('  - Смешанные:', mixedPaths);
                    
                    if (curvedPaths > 0 && straightPaths === 0) {
                        console.warn('HTML DEBUG: ⚠️ ВНИМАНИЕ: Все пути скругленные - ELK может не работать!');
                    } else if (straightPaths > 0) {
                        console.log('HTML DEBUG: ✅ Найдены угловатые пути - ELK работает корректно');
                    }
                    
                    // Проверяем наличие групп с классами, указывающими на renderer
                    var groups = svg.querySelectorAll('g');
                    var elkGroups = 0;
                    groups.forEach(function(group) {
                        var groupClass = group.getAttribute('class') || '';
                        if (groupClass.indexOf('elk') !== -1 || groupClass.indexOf('orthogonal') !== -1) {
                            elkGroups++;
                        }
                    });
                    console.log('HTML DEBUG: Групп с признаками ELK:', elkGroups);
                });
                
                console.log('=== HTML DEBUG: Анализ завершен ===');
            }
            
            function initMermaid() {
                try {
                    // Проверка доступности mermaid
                    if (typeof window === 'undefined' || !window.mermaid) {
                        console.warn('HTML DEBUG: Mermaid не найден, повторная попытка через 200ms...');
                        setTimeout(initMermaid, 200);
                        return;
                    }
                    
                    console.log('HTML DEBUG: === Инициализация Mermaid ===');
                    console.log('HTML DEBUG: Mermaid найден:', window.mermaid);
                    
                    // Проверяем конфигурацию
                    if (window.mermaid.getConfig) {
                        try {
                            var config = window.mermaid.getConfig();
                            console.log('HTML DEBUG: Текущая конфигурация:', JSON.stringify(config, null, 2));
                            if (config.flowchart) {
                                console.log('HTML DEBUG: flowchart.defaultRenderer:', config.flowchart.defaultRenderer);
                                if (config.flowchart.defaultRenderer !== 'elk') {
                                    console.warn('HTML DEBUG: ⚠️ defaultRenderer не установлен в "elk"!');
                                }
                            }
                        } catch (e) {
                            console.warn('HTML DEBUG: Не удалось получить конфигурацию:', e);
                        }
                    }
                    
                    // Используем стандартный mermaid.run() для обработки всех диаграмм
                    if (typeof window.mermaid.run === 'function') {
                        console.log('HTML DEBUG: Вызываем mermaid.run()');
                        try {
                            var runPromise = window.mermaid.run();
                            if (runPromise && typeof runPromise.then === 'function') {
                                runPromise.then(function() {
                                    console.log('HTML DEBUG: ✅ Mermaid.run() выполнен успешно');
                                    
                                    // Даем время на отрисовку, затем анализируем
                                    setTimeout(function() {
                                        analyzeSVGElements();
                                    }, 500);
                                }).catch(function(err) {
                                    console.error('HTML DEBUG: ❌ Ошибка при выполнении mermaid.run():', err);
                                    console.error('HTML DEBUG: Стек ошибки:', err.stack);
                                });
                            } else {
                                // Если run() не вернул Promise, анализируем через некоторое время
                                setTimeout(function() {
                                    analyzeSVGElements();
                                }, 1000);
                            }
                        } catch (err) {
                            console.error('HTML DEBUG: ❌ Ошибка при вызове mermaid.run():', err);
                            console.error('HTML DEBUG: Стек ошибки:', err.stack);
                        }
                    } else {
                        console.log('HTML DEBUG: mermaid.run() не найден, диаграммы должны обработаться автоматически');
                        // Анализируем через некоторое время
                        setTimeout(function() {
                            analyzeSVGElements();
                        }, 2000);
                    }
                } catch (e) {
                    console.error('HTML DEBUG: ❌ Ошибка при инициализации Mermaid:', e);
                    console.error('HTML DEBUG: Стек ошибки:', e.stack);
                }
            }
            
            // Запуск инициализации после загрузки DOM
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function() {
                    console.log('HTML DEBUG: DOM загружен, запускаем инициализацию...');
                    setTimeout(initMermaid, 100);
                });
            } else {
                console.log('HTML DEBUG: DOM уже загружен, запускаем инициализацию...');
                setTimeout(initMermaid, 100);
            }
        })();
    </script>
</body>
</html>
